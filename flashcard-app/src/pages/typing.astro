---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Typing Practice">
	<script is:inline>
		window.__BASE_URL__ = '/leetcode-study/';
	</script>
	<main>
		<div id="typing-app">
			<div class="controls">
				<div class="toggle-group">
					<label class="toggle">
						<input type="checkbox" id="include-comments" checked>
						<span>Include Comments</span>
					</label>
				</div>
				<div class="nav-controls">
					<button id="restart-btn">üîÑ Restart</button>
					<button id="prev-btn">‚Üê Previous</button>
					<button id="next-btn">Next ‚Üí</button>
					<span id="counter">1 / 0</span>
				</div>
			</div>

			<div class="pattern-name" id="pattern-name">Loading...</div>
			
			<div class="stats">
				<span id="wpm">0 WPM</span>
				<span id="accuracy">100% Accuracy</span>
				<span id="time">0:00</span>
			</div>

			<div class="typing-container">
				<pre id="code-display" class="code-display"></pre>
				<textarea id="typing-input" class="typing-input" placeholder="Start typing..." spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
			</div>
			
			<div class="completion-message" id="completion-message">
				<h2>üéâ Complete!</h2>
				<p id="final-stats"></p>
				<button id="next-pattern-btn">Next Pattern ‚Üí</button>
			</div>
		</div>
	</main>
</Layout>

<style>
	main {
		margin: auto;
		padding: 1rem;
		width: 100%;
		max-width: 900px;
		color: white;
		font-size: 16px;
		line-height: 1.6;
	}

	#typing-app {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.controls {
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
	}

	.toggle-group {
		display: flex;
		gap: 1rem;
	}

	.toggle {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		color: #9ca3af;
	}

	.toggle input {
		width: 18px;
		height: 18px;
		cursor: pointer;
	}

	.toggle:has(input:checked) {
		color: white;
	}

	.nav-controls {
		display: flex;
		gap: 0.75rem;
		align-items: center;
	}

	.nav-controls button {
		padding: 0.5rem 1rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 14px;
	}

	.nav-controls button:hover {
		background: #3730a3;
	}

	#counter {
		color: #9ca3af;
		font-weight: bold;
	}

	.pattern-name {
		font-size: 1.25rem;
		font-weight: bold;
		color: #60a5fa;
		text-align: center;
	}

	.stats {
		display: flex;
		justify-content: center;
		gap: 2rem;
		font-size: 1rem;
		color: #9ca3af;
	}

	.stats span {
		padding: 0.25rem 0.75rem;
		background: #1f2937;
		border-radius: 4px;
	}

	.typing-container {
		position: relative;
		background: #111827;
		border-radius: 8px;
		padding: 1.5rem;
		min-height: 300px;
	}

	.code-display {
		font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
		font-size: 14px;
		line-height: 1.6;
		margin: 0;
		white-space: pre-wrap;
		word-break: break-all;
	}

	.char {
		color: #4b5563;
	}

	.char.correct {
		color: #10b981;
	}

	.char.incorrect {
		color: #ef4444;
		background: #7f1d1d;
	}

	.char.current {
		background: #3b82f6;
		color: white;
	}

	.typing-input {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: text;
		font-size: 16px;
	}

	.completion-message {
		display: none;
		text-align: center;
		padding: 2rem;
		background: #1f2937;
		border-radius: 8px;
	}

	.completion-message.show {
		display: block;
	}

	.completion-message h2 {
		color: #10b981;
		margin-bottom: 1rem;
	}

	.completion-message p {
		color: #9ca3af;
		margin-bottom: 1.5rem;
	}

	#next-pattern-btn {
		padding: 0.75rem 1.5rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 14px;
	}

	#next-pattern-btn:hover {
		background: #3730a3;
	}
</style>

<script>
	class TypingApp {
		constructor() {
			this.patterns = [];
			this.currentIndex = 0;
			this.includeComments = true;
			this.currentCode = '';
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			this.timerInterval = null;
			this.init();
		}

		async init() {
			await this.loadPatterns();
			this.setupEventListeners();
			this.displayCurrentPattern();
		}

		async loadPatterns() {
			try {
				const base = window.__BASE_URL__ || '/';
				const response = await fetch(`${base}api/flashcards.json`);
				const flashcards = await response.json();
				
				// Filter to set2 only
				const set2Cards = flashcards.filter(c => c.set === 'flashcards_set2');
				
				for (const card of set2Cards) {
					try {
						const backResponse = await fetch(`${base}${card.backFile.slice(1)}`);
						if (backResponse.ok) {
							const content = await backResponse.text();
							const code = this.extractCode(content);
							if (code) {
								this.patterns.push({
									name: this.formatName(card.baseName),
									code: code,
									codeNoComments: this.removeComments(code)
								});
							}
						}
					} catch (e) {
						console.warn(`Failed to load ${card.id}`);
					}
				}
				
				document.getElementById('counter').textContent = `1 / ${this.patterns.length}`;
			} catch (error) {
				console.error('Failed to load patterns:', error);
			}
		}

		extractCode(markdown) {
			const match = markdown.match(/```python\n([\s\S]*?)```/);
			return match ? match[1].trim() : null;
		}

		removeComments(code) {
			return code
				.split('\n')
				.filter(line => !line.trim().startsWith('#'))
				.join('\n');
		}

		formatName(baseName) {
			return baseName
				.replace(/^\d+-/, '')
				.split('-')
				.map(w => w.charAt(0).toUpperCase() + w.slice(1))
				.join(' ');
		}

		setupEventListeners() {
			const input = document.getElementById('typing-input');
			const commentsToggle = document.getElementById('include-comments');
			
			input.addEventListener('input', () => this.handleInput());
			input.addEventListener('keydown', (e) => {
				if (e.key === 'Tab') {
					e.preventDefault();
					// Insert 4 spaces for tab
					const start = input.selectionStart;
					input.value = input.value.slice(0, start) + '    ' + input.value.slice(start);
					input.selectionStart = input.selectionEnd = start + 4;
					this.handleInput();
				}
			});
			
			commentsToggle.addEventListener('change', () => {
				this.includeComments = commentsToggle.checked;
				this.restart();
			});
			
			document.getElementById('restart-btn').addEventListener('click', () => this.restart());
			document.getElementById('prev-btn').addEventListener('click', () => this.prevPattern());
			document.getElementById('next-btn').addEventListener('click', () => this.nextPattern());
			document.getElementById('next-pattern-btn').addEventListener('click', () => this.nextPattern());
			
			// Focus input on click
			document.querySelector('.typing-container').addEventListener('click', () => {
				input.focus();
			});
		}

		displayCurrentPattern() {
			if (this.patterns.length === 0) {
				document.getElementById('pattern-name').textContent = 'Loading patterns...';
				return;
			}

			const pattern = this.patterns[this.currentIndex];
			this.currentCode = this.includeComments ? pattern.code : pattern.codeNoComments;
			
			document.getElementById('pattern-name').textContent = pattern.name;
			document.getElementById('counter').textContent = `${this.currentIndex + 1} / ${this.patterns.length}`;
			
			this.renderCode();
			this.resetStats();
			
			document.getElementById('typing-input').value = '';
			document.getElementById('typing-input').focus();
			document.getElementById('completion-message').classList.remove('show');
		}

		renderCode(typed = '') {
			const display = document.getElementById('code-display');
			let html = '';
			
			for (let i = 0; i < this.currentCode.length; i++) {
				const char = this.currentCode[i];
				const typedChar = typed[i];
				let className = 'char';
				
				if (i < typed.length) {
					className += typedChar === char ? ' correct' : ' incorrect';
				} else if (i === typed.length) {
					className += ' current';
				}
				
				// Escape HTML
				let displayChar = char;
				if (char === '<') displayChar = '&lt;';
				else if (char === '>') displayChar = '&gt;';
				else if (char === '&') displayChar = '&amp;';
				else if (char === ' ') displayChar = ' ';
				else if (char === '\n') displayChar = '\n';
				
				html += `<span class="${className}">${displayChar}</span>`;
			}
			
			display.innerHTML = html;
		}

		handleInput() {
			const input = document.getElementById('typing-input');
			const typed = input.value;
			
			// Start timer on first keystroke
			if (!this.startTime && typed.length > 0) {
				this.startTime = Date.now();
				this.startTimer();
			}
			
			this.renderCode(typed);
			this.updateStats(typed);
			
			// Check completion
			if (typed === this.currentCode) {
				this.complete();
			}
		}

		updateStats(typed) {
			this.typedChars = typed.length;
			this.correctChars = 0;
			
			for (let i = 0; i < typed.length; i++) {
				if (typed[i] === this.currentCode[i]) {
					this.correctChars++;
				}
			}
			
			const accuracy = this.typedChars > 0 
				? Math.round((this.correctChars / this.typedChars) * 100) 
				: 100;
			
			document.getElementById('accuracy').textContent = `${accuracy}% Accuracy`;
			
			if (this.startTime) {
				const minutes = (Date.now() - this.startTime) / 60000;
				const words = this.correctChars / 5;
				const wpm = minutes > 0 ? Math.round(words / minutes) : 0;
				document.getElementById('wpm').textContent = `${wpm} WPM`;
			}
		}

		startTimer() {
			this.timerInterval = setInterval(() => {
				const seconds = Math.floor((Date.now() - this.startTime) / 1000);
				const mins = Math.floor(seconds / 60);
				const secs = seconds % 60;
				document.getElementById('time').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
			}, 1000);
		}

		resetStats() {
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
				this.timerInterval = null;
			}
			document.getElementById('wpm').textContent = '0 WPM';
			document.getElementById('accuracy').textContent = '100% Accuracy';
			document.getElementById('time').textContent = '0:00';
		}

		complete() {
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
			}
			
			const seconds = Math.floor((Date.now() - this.startTime) / 1000);
			const mins = Math.floor(seconds / 60);
			const secs = seconds % 60;
			const accuracy = Math.round((this.correctChars / this.typedChars) * 100);
			const wpm = document.getElementById('wpm').textContent;
			
			document.getElementById('final-stats').textContent = 
				`${wpm} ‚Ä¢ ${accuracy}% Accuracy ‚Ä¢ Time: ${mins}:${secs.toString().padStart(2, '0')}`;
			document.getElementById('completion-message').classList.add('show');
		}

		restart() {
			this.displayCurrentPattern();
		}

		nextPattern() {
			this.currentIndex = (this.currentIndex + 1) % this.patterns.length;
			this.displayCurrentPattern();
		}

		prevPattern() {
			this.currentIndex = this.currentIndex === 0 
				? this.patterns.length - 1 
				: this.currentIndex - 1;
			this.displayCurrentPattern();
		}
	}

	document.addEventListener('DOMContentLoaded', () => {
		new TypingApp();
	});
</script>
</Layout>
