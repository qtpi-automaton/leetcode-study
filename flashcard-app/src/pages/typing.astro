---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Typing Practice">
	<script is:inline>
		window.__BASE_URL__ = '/leetcode-study/';
	</script>
	<!-- Prism.js for syntax highlighting -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" crossorigin="anonymous">
	<script is:inline src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js" crossorigin="anonymous"></script>
	<script is:inline src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js" crossorigin="anonymous"></script>
	
	<main>
		<div id="typing-app">
			<div class="controls">
				<div class="toggle-group">
					<label class="toggle">
						<input type="checkbox" id="include-comments" checked>
						<span>Include Comments</span>
					</label>
				</div>
				<div class="nav-controls">
					<button id="restart-btn">üîÑ Restart</button>
					<button id="prev-btn">‚Üê Prev</button>
					<button id="next-btn">Next ‚Üí</button>
					<span id="counter">1 / 0</span>
				</div>
			</div>

			<div class="pattern-name" id="pattern-name">Loading...</div>
			
			<div class="stats">
				<span id="wpm">0 WPM</span>
				<span id="accuracy">100%</span>
				<span id="time">0:00</span>
			</div>

			<div class="typing-container">
				<div class="panel target-panel">
					<div class="panel-label">Target ‚Äî type what you see</div>
					<pre id="target-code" class="code-block"></pre>
				</div>
				
				<div class="panel input-panel">
					<div class="panel-label">Your Input</div>
					<div class="input-wrapper">
						<pre id="typed-display" class="code-block typed-code"></pre>
						<textarea id="typing-input" class="typing-input" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
					</div>
				</div>
			</div>
			
			<div class="completion-message" id="completion-message">
				<h2>üéâ Complete!</h2>
				<p id="final-stats"></p>
				<button id="next-pattern-btn">Next Pattern ‚Üí</button>
			</div>
		</div>
	</main>
</Layout>

<style>
	main {
		margin: auto;
		padding: 1rem;
		width: 100%;
		max-width: 1000px;
		color: white;
		font-size: 16px;
	}

	#typing-app {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.controls {
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
	}

	.toggle-group {
		display: flex;
		gap: 1rem;
	}

	.toggle {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		color: #9ca3af;
	}

	.toggle input {
		width: 18px;
		height: 18px;
		cursor: pointer;
	}

	.toggle:has(input:checked) {
		color: white;
	}

	.nav-controls {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.nav-controls button {
		padding: 0.5rem 0.75rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 13px;
	}

	.nav-controls button:hover {
		background: #3730a3;
	}

	#counter {
		color: #9ca3af;
		font-weight: bold;
		margin-left: 0.5rem;
	}

	.pattern-name {
		font-size: 1.25rem;
		font-weight: bold;
		color: #60a5fa;
		text-align: center;
	}

	.stats {
		display: flex;
		justify-content: center;
		gap: 1.5rem;
		font-size: 0.9rem;
		color: #9ca3af;
	}

	.stats span {
		padding: 0.25rem 0.75rem;
		background: #1f2937;
		border-radius: 4px;
	}

	.typing-container {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.panel {
		background: #1e293b;
		border-radius: 8px;
		overflow: hidden;
	}

	.panel-label {
		background: #334155;
		padding: 0.5rem 1rem;
		font-size: 0.8rem;
		color: #94a3b8;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}

	.target-panel .panel-label {
		background: #1e3a5f;
		color: #60a5fa;
	}

	.input-panel .panel-label {
		background: #14532d;
		color: #4ade80;
	}

	.code-block {
		margin: 0;
		padding: 1rem;
		font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
		font-size: 14px;
		line-height: 1.6;
		min-height: 200px;
		overflow-x: auto;
		background: #0f172a;
	}

	.input-wrapper {
		position: relative;
	}

	.typed-code {
		white-space: pre-wrap;
		word-break: break-all;
	}

	.typing-input {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: text;
		font-size: 16px;
		resize: none;
	}

	.completion-message {
		display: none;
		text-align: center;
		padding: 2rem;
		background: #1f2937;
		border-radius: 8px;
	}

	.completion-message.show {
		display: block;
	}

	.completion-message h2 {
		color: #10b981;
		margin-bottom: 1rem;
	}

	.completion-message p {
		color: #9ca3af;
		margin-bottom: 1.5rem;
	}

	#next-pattern-btn {
		padding: 0.75rem 1.5rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 14px;
	}

	#next-pattern-btn:hover {
		background: #3730a3;
	}
</style>

<style is:global>
	.char-correct-bg {
		background: rgba(74, 222, 128, 0.25);
		color: #4ade80;
	}

	.char-incorrect-bg {
		background: rgba(239, 68, 68, 0.35);
		color: #fca5a5;
		text-decoration: underline wavy #ef4444;
	}

	.char-pending {
		color: #64748b;
	}

	.char-current {
		background: rgba(96, 165, 250, 0.4);
		color: white;
		animation: pulse-char 1s infinite;
	}

	@keyframes pulse-char {
		0%, 100% { background: rgba(96, 165, 250, 0.4); }
		50% { background: rgba(96, 165, 250, 0.7); }
	}

	.cursor {
		display: inline-block;
		width: 2px;
		height: 1.2em;
		background: #60a5fa;
		animation: blink-cursor 1s infinite;
		vertical-align: text-bottom;
		margin-left: 1px;
	}

	@keyframes blink-cursor {
		0%, 50% { opacity: 1; }
		51%, 100% { opacity: 0; }
	}

	.char-correct {
		color: #4ade80;
	}

	.char-incorrect {
		color: #ef4444;
		background: #450a0a;
		text-decoration: underline wavy #ef4444;
	}
</style>

<script>
	// UnifiedGraphSolver implementation
	const Mode = {
		BFS: 'BFS',
		DFS: 'DFS'
	};

	class UnifiedGraphSolver {
		solve(data, mode = Mode.BFS, track_meta = false, use_visited = true) {
			const visited = (track_meta ? {} : new Set()) && use_visited ? (track_meta ? {} : new Set()) : null;
			let result = this._init_result(visited);
			const all_starts = this._get_start_points(data);
			
			if (mode === Mode.BFS && this._is_multi_source()) {
				this._bfs(all_starts, data, visited, track_meta);
			} else {
				for (const start of all_starts) {
					if (!this._check_visited(visited, start)) {
						result = this._update_result(result);
						const nodes = [start];
						if (mode === Mode.BFS) {
							this._bfs(nodes, data, visited, track_meta);
						} else {
							this._dfs(nodes, data, visited, track_meta);
						}
					}
				}
			}
			return result;
		}

		_bfs(start_nodes, data, visited, track_meta) {
			const container = [];
			for (const node of start_nodes) {
				this._mark(visited, node, null, track_meta);
				container.push([node, 0]);
			}
			
			while (container.length > 0) {
				const [curr, level] = container.shift();
				this._process_node(curr, level);
				
				for (const neighbor of this._get_neighbors(curr, data)) {
					if (this._is_valid(neighbor, data) && !this._check_visited(visited, neighbor)) {
						this._mark(visited, neighbor, curr, track_meta);
						container.push([neighbor, level + 1]);
					}
				}
			}
		}

		_dfs(start_nodes, data, visited, track_meta) {
			const container = [];
			for (const node of start_nodes) {
				container.push([node, null]);
			}
			
			while (container.length > 0) {
				const [curr, parent] = container.pop();
				if (this._check_visited(visited, curr)) continue;
				
				this._mark(visited, curr, parent, track_meta);
				this._process_node(curr, 0);
				
				for (const neighbor of this._get_neighbors(curr, data)) {
					if (this._is_valid(neighbor, data) && !this._check_visited(visited, neighbor)) {
						container.push([neighbor, curr]);
					}
				}
			}
		}

		_check_visited(visited, node) {
			if (visited === null) return false;
			return visited instanceof Set ? visited.has(node) : node in visited;
		}

		_mark(visited, node, prev, track_meta) {
			if (visited === null) return;
			if (track_meta) {
				visited[node] = prev;
			} else {
				visited.add(node);
			}
		}

		_init_result(visited) { return visited; }
		_update_result(result) { return result; }
		_is_multi_source() { return false; }
		_get_start_points(data) { return []; }
		_get_neighbors(node, data) { return []; }
		_is_valid(node, data) { return true; }
		_process_node(node, level) { }
	}

	// TypingApp class that uses the patterns
	class TypingApp {
		constructor() {
			this.patterns = [];
			this.currentIndex = 0;
			this.includeComments = true;
			this.currentCode = '';
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			this.timerInterval = null;
			this.init();
		}

		async init() {
			await this.loadPatterns();
			this.setupEventListeners();
			this.displayCurrentPattern();
		}

		async loadPatterns() {
			// Add the UnifiedGraphSolver as the first pattern
			const unifiedSolverCode = `from collections import deque
from enum import Enum, auto

class Mode(Enum): 
    BFS = auto()
    DFS = auto()

class UnifiedGraphSolver:
    def solve(self, data, mode=Mode.BFS, track_meta=False, use_visited=True):
        visited = ({} if track_meta else set()) if use_visited else None
        result = self._init_result(visited)
        all_starts = self._get_start_points(data)
        
        if mode == Mode.BFS and self._is_multi_source():
            self._bfs(all_starts, data, visited, track_meta)
        else:
            for start in all_starts:
                if not self._check_visited(visited, start):
                    result = self._update_result(result)
                    nodes = [start]
                    if mode == Mode.BFS: 
                        self._bfs(nodes, data, visited, track_meta)
                    else:                
                        self._dfs(nodes, data, visited, track_meta)
        return result

    def _bfs(self, start_nodes, data, visited, track_meta):
        container = deque()
        for node in start_nodes:
            self._mark(visited, node, None, track_meta)
            container.append((node, 0))
        
        while container:
            curr, level = container.popleft() 
            self._process_node(curr, level)
            
            for neighbor in self._get_neighbors(curr, data):
                if self._is_valid(neighbor, data) and not self._check_visited(visited, neighbor):
                    self._mark(visited, neighbor, curr, track_meta)
                    container.append((neighbor, level + 1)) 

    def _dfs(self, start_nodes, data, visited, track_meta):
        container = []
        for node in start_nodes:
            container.append((node, None))
        
        while container:
            curr, parent = container.pop() 
            if self._check_visited(visited, curr): 
                continue
            self._mark(visited, curr, parent, track_meta)
            self._process_node(curr, 0) 
            
            for neighbor in self._get_neighbors(curr, data):
                if self._is_valid(neighbor, data) and not self._check_visited(visited, neighbor):
                    container.append((neighbor, curr)) 

    def _check_visited(self, visited, node):
        if visited is None: 
            return False 
        return node in visited

    def _mark(self, visited, node, prev, track_meta):
        if visited is None: 
            return 
        if track_meta: 
            visited[node] = prev
        else:          
            visited.add(node)

    def _init_result(self, visited): 
        return visited
    def _update_result(self, result): 
        return result
    def _is_multi_source(self): 
        return False 
    def _get_start_points(self, data): 
        return []
    def _get_neighbors(self, node, data): 
        return []
    def _is_valid(self, node, data): 
        return True
    def _process_node(self, node, level): 
        pass`;

			this.patterns.push({
				name: 'Unified Graph Solver',
				code: unifiedSolverCode,
				codeNoComments: this.removeComments(unifiedSolverCode)
			});

			try {
				const base = window.__BASE_URL__ || '/';
				const response = await fetch(`${base}api/flashcards.json`);
				const flashcards = await response.json();
				
				const set2Cards = flashcards.filter(c => c.set === 'flashcards_set2');
				
				for (const card of set2Cards) {
					try {
						const backResponse = await fetch(`${base}${card.backFile.slice(1)}`);
						if (backResponse.ok) {
							const content = await backResponse.text();
							const code = this.extractCode(content);
							if (code) {
								this.patterns.push({
									name: this.formatName(card.baseName),
									code: code,
									codeNoComments: this.removeComments(code)
								});
							}
						}
					} catch (e) {
						console.warn(`Failed to load ${card.id}`);
					}
				}
				
				document.getElementById('counter').textContent = `1 / ${this.patterns.length}`;
			} catch (error) {
				console.error('Failed to load patterns:', error);
			}
		}

		extractCode(markdown) {
			const match = markdown.match(/```python\n([\s\S]*?)```/);
			return match ? match[1].trim() : null;
		}

		removeComments(code) {
			return code
				.split('\n')
				.filter(line => !line.trim().startsWith('#'))
				.join('\n');
		}

		formatName(baseName) {
			return baseName
				.replace(/^\d+-/, '')
				.split('-')
				.map(w => w.charAt(0).toUpperCase() + w.slice(1))
				.join(' ');
		}

		setupEventListeners() {
			const input = document.getElementById('typing-input');
			const commentsToggle = document.getElementById('include-comments');
			
			input.addEventListener('input', () => this.handleInput());
			input.addEventListener('keydown', (e) => {
				if (e.key === 'Tab') {
					e.preventDefault();
					const start = input.selectionStart;
					input.value = input.value.slice(0, start) + '    ' + input.value.slice(start);
					input.selectionStart = input.selectionEnd = start + 4;
					this.handleInput();
				}
			});
			
			commentsToggle.addEventListener('change', () => {
				this.includeComments = commentsToggle.checked;
				this.updateCodeVersion();
			});
			
			document.getElementById('restart-btn').addEventListener('click', () => this.restart());
			document.getElementById('prev-btn').addEventListener('click', () => this.prevPattern());
			document.getElementById('next-btn').addEventListener('click', () => this.nextPattern());
			document.getElementById('next-pattern-btn').addEventListener('click', () => this.nextPattern());
			
			document.querySelector('.input-panel').addEventListener('click', () => {
				input.focus();
			});
		}

		displayCurrentPattern() {
			if (this.patterns.length === 0) {
				document.getElementById('pattern-name').textContent = 'Loading patterns...';
				return;
			}

			const pattern = this.patterns[this.currentIndex];
			this.currentCode = this.includeComments ? pattern.code : pattern.codeNoComments;
			
			document.getElementById('pattern-name').textContent = pattern.name;
			document.getElementById('counter').textContent = `${this.currentIndex + 1} / ${this.patterns.length}`;
			
			this.renderTargetCode('');
			this.renderTypedCode('');
			this.resetStats();
			
			document.getElementById('typing-input').value = '';
			document.getElementById('typing-input').focus();
			document.getElementById('completion-message').classList.remove('show');
		}

		renderTargetCode(typed) {
			const display = document.getElementById('target-code');
			let html = '';
			
			for (let i = 0; i < this.currentCode.length; i++) {
				const targetChar = this.currentCode[i];
				const typedChar = typed[i];
				let className = 'char-pending';
				
				if (i < typed.length) {
					className = typedChar === targetChar ? 'char-correct-bg' : 'char-incorrect-bg';
				} else if (i === typed.length) {
					className = 'char-current';
				}
				
				html += `<span class="${className}">${this.escapeHtml(targetChar)}</span>`;
			}
			
			display.innerHTML = html;
		}

		renderTypedCode(typed) {
			const display = document.getElementById('typed-display');
			
			// Create a code element for Prism
			const codeEl = document.createElement('code');
			codeEl.className = 'language-python';
			codeEl.textContent = typed;
			
			// Apply syntax highlighting
			if (window.Prism) {
				Prism.highlightElement(codeEl);
			}
			
			// Add cursor at the end
			display.innerHTML = codeEl.innerHTML + '<span class="cursor"></span>';
		}

		escapeHtml(char) {
			if (char === '<') return '&lt;';
			if (char === '>') return '&gt;';
			if (char === '&') return '&amp;';
			if (char === '\n') return '\n';
			return char;
		}

		updateCodeVersion() {
			// Switch code version without resetting typed input
			const pattern = this.patterns[this.currentIndex];
			this.currentCode = this.includeComments ? pattern.code : pattern.codeNoComments;
			const typed = document.getElementById('typing-input').value;
			this.renderTargetCode(typed);
			this.renderTypedCode(typed);
			this.updateStats(typed);
		}

		handleInput() {
			const input = document.getElementById('typing-input');
			const typed = input.value;
			
			if (!this.startTime && typed.length > 0) {
				this.startTime = Date.now();
				this.startTimer();
			}
			
			this.renderTargetCode(typed);
			this.renderTypedCode(typed);
			this.updateStats(typed);
			
			if (typed === this.currentCode) {
				this.complete();
			}
		}

		updateStats(typed) {
			this.typedChars = typed.length;
			this.correctChars = 0;
			
			for (let i = 0; i < typed.length; i++) {
				if (typed[i] === this.currentCode[i]) {
					this.correctChars++;
				}
			}
			
			const accuracy = this.typedChars > 0 
				? Math.round((this.correctChars / this.typedChars) * 100) 
				: 100;
			
			document.getElementById('accuracy').textContent = `${accuracy}%`;
			
			if (this.startTime) {
				const minutes = (Date.now() - this.startTime) / 60000;
				const words = this.correctChars / 5;
				const wpm = minutes > 0 ? Math.round(words / minutes) : 0;
				document.getElementById('wpm').textContent = `${wpm} WPM`;
			}
		}

		startTimer() {
			this.timerInterval = setInterval(() => {
				const seconds = Math.floor((Date.now() - this.startTime) / 1000);
				const mins = Math.floor(seconds / 60);
				const secs = seconds % 60;
				document.getElementById('time').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
			}, 1000);
		}

		resetStats() {
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
				this.timerInterval = null;
			}
			document.getElementById('wpm').textContent = '0 WPM';
			document.getElementById('accuracy').textContent = '100%';
			document.getElementById('time').textContent = '0:00';
		}

		complete() {
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
			}
			
			const seconds = Math.floor((Date.now() - this.startTime) / 1000);
			const mins = Math.floor(seconds / 60);
			const secs = seconds % 60;
			const accuracy = Math.round((this.correctChars / this.typedChars) * 100);
			const wpm = document.getElementById('wpm').textContent;
			
			document.getElementById('final-stats').textContent = 
				`${wpm} ‚Ä¢ ${accuracy}% Accuracy ‚Ä¢ Time: ${mins}:${secs.toString().padStart(2, '0')}`;
			document.getElementById('completion-message').classList.add('show');
		}

		restart() {
			this.displayCurrentPattern();
		}

		nextPattern() {
			this.currentIndex = (this.currentIndex + 1) % this.patterns.length;
			this.displayCurrentPattern();
		}

		prevPattern() {
			this.currentIndex = this.currentIndex === 0 
				? this.patterns.length - 1 
				: this.currentIndex - 1;
			this.displayCurrentPattern();
		}
	}

	document.addEventListener('DOMContentLoaded', () => {
		new TypingApp();
	});
</script>
</Layout>
