---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Problem Practice">
	<script is:inline>
		window.__BASE_URL__ = '/leetcode-study/';
	</script>
	<!-- Prism.js for syntax highlighting -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" crossorigin="anonymous">
	<script is:inline src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js" crossorigin="anonymous"></script>
	<script is:inline src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js" crossorigin="anonymous"></script>
	<!-- Marked for Markdown parsing -->
	<script is:inline src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	
	<main>
		<div id="typing-app">
			<div class="controls">
				<div class="toggle-group">
					<label class="toggle">
						<input type="checkbox" id="include-comments" checked>
						<span>Include Comments</span>
					</label>
					<label class="toggle">
						<input type="checkbox" id="show-target" checked>
						<span>Show Target</span>
					</label>
				</div>
				<div class="nav-controls">
					<button id="restart-btn">üîÑ Restart</button>
					<button id="prev-btn">‚Üê Prev</button>
					<button id="next-btn">Next ‚Üí</button>
					<span id="counter">1 / 0</span>
				</div>
			</div>

			<div class="pattern-name" id="pattern-name">Loading...</div>
			
			<div class="stats">
				<span id="wpm">0 WPM</span>
				<span id="accuracy">100%</span>
				<span id="time">0:00</span>
			</div>

			<div class="problems-container">
				<div class="typing-section">
					<div class="typing-container">
						<div class="panel target-panel">
							<div class="panel-label">Target ‚Äî type what you see</div>
							<pre id="target-code" class="code-block"></pre>
						</div>
						
						<div class="panel input-panel">
							<div class="panel-label">Your Input</div>
							<div class="input-wrapper">
								<pre id="typed-display" class="code-block typed-code"></pre>
								<textarea id="typing-input" class="typing-input" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
							</div>
						</div>
					</div>
				</div>
				<div class="problem-section">
					<div class="panel problem-panel">
						<div class="panel-label">Problem Description</div>
						<div id="problem-content" class="markdown-content">
							<p>Select a problem to begin.</p>
						</div>
					</div>
				</div>
			</div>
			
			<div class="completion-message" id="completion-message">
				<h2>üéâ Complete!</h2>
				<p id="final-stats"></p>
				<button id="next-pattern-btn">Next Pattern ‚Üí</button>
			</div>
		</div>
	</main>
</Layout>

<style>
	main {
		margin: auto;
		padding: 1rem;
		width: 100%;
		max-width: 1400px;
		color: white;
		font-size: 16px;
	}

	#typing-app {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.controls {
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
	}

	.toggle-group {
		display: flex;
		gap: 1rem;
		align-items: center;
	}



	.toggle {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		color: #9ca3af;
	}

	.toggle input {
		width: 18px;
		height: 18px;
		cursor: pointer;
	}

	.toggle:has(input:checked) {
		color: white;
	}

	.nav-controls {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.nav-controls button {
		padding: 0.5rem 0.75rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 13px;
	}

	.nav-controls button:hover {
		background: #3730a3;
	}

	#counter {
		color: #9ca3af;
		font-weight: bold;
		margin-left: 0.5rem;
	}

	.pattern-name {
		font-size: 1.25rem;
		font-weight: bold;
		color: #60a5fa;
		text-align: center;
	}

	.stats {
		display: flex;
		justify-content: center;
		gap: 1.5rem;
		font-size: 0.9rem;
		color: #9ca3af;
	}

	.stats span {
		padding: 0.25rem 0.75rem;
		background: #1f2937;
		border-radius: 4px;
	}

	.problems-container {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 1.5rem;
		align-items: start;
	}

	.typing-section {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.problem-section {
		position: sticky;
		top: 1rem;
		height: calc(100vh - 4rem);
		overflow: hidden;
		display: flex;
		flex-direction: column;
	}

	.problem-panel {
		flex: 1;
		display: flex;
		flex-direction: column;
	}

	.markdown-content {
		padding: 1.5rem;
		overflow-y: auto;
		flex: 1;
		color: #e2e8f0;
		line-height: 1.6;
		font-size: 15px;
	}
	
	.markdown-content h1, 
	.markdown-content h2, 
	.markdown-content h3 {
		color: #60a5fa;
		margin-top: 1.5rem;
		margin-bottom: 0.75rem;
	}

	.markdown-content h1:first-child {
		margin-top: 0;
	}

	.markdown-content pre {
		background: #0f172a;
		padding: 1rem;
		border-radius: 6px;
		overflow-x: auto;
		margin: 1rem 0;
	}
	
	.markdown-content code {
		font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
		font-size: 0.9em;
		background: rgba(15, 23, 42, 0.5);
		padding: 0.2em 0.4em;
		border-radius: 4px;
	}
	
	.markdown-content pre code {
		background: transparent;
		padding: 0;
	}

	.typing-container {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.target-panel {
		transition: opacity 0.3s ease, height 0.3s ease;
	}

	.target-panel.hidden {
		opacity: 0;
		height: 0;
		overflow: hidden;
		margin: 0;
		padding: 0;
	}

	.panel {
		background: #1e293b;
		border-radius: 8px;
		overflow: hidden;
	}

	.panel-label {
		background: #334155;
		padding: 0.5rem 1rem;
		font-size: 0.8rem;
		color: #94a3b8;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}

	.target-panel .panel-label {
		background: #1e3a5f;
		color: #60a5fa;
	}

	.input-panel .panel-label {
		background: #14532d;
		color: #4ade80;
	}

	.code-block {
		margin: 0;
		padding: 1rem;
		font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
		font-size: 14px;
		line-height: 1.6;
		min-height: 200px;
		overflow-x: auto;
		background: #0f172a;
	}

	.input-wrapper {
		position: relative;
	}

	.typed-code {
		white-space: pre-wrap;
		word-break: break-all;
	}

	.typing-input {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: text;
		font-size: 16px;
		resize: none;
	}

	.completion-message {
		display: none;
		text-align: center;
		padding: 2rem;
		background: #1f2937;
		border-radius: 8px;
	}

	.completion-message.show {
		display: block;
	}

	.completion-message h2 {
		color: #10b981;
		margin-bottom: 1rem;
	}

	.completion-message p {
		color: #9ca3af;
		margin-bottom: 1.5rem;
	}

	#next-pattern-btn {
		padding: 0.75rem 1.5rem;
		background: #4f46e5;
		color: white;
		border: none;
		border-radius: 6px;
		cursor: pointer;
		font-size: 14px;
	}

	#next-pattern-btn:hover {
		background: #3730a3;
	}
</style>

<style is:global>
	.char-correct-bg {
		background: rgba(74, 222, 128, 0.25);
		color: #4ade80;
	}

	.char-incorrect-bg {
		background: rgba(239, 68, 68, 0.35);
		color: #fca5a5;
		text-decoration: underline wavy #ef4444;
	}

	.char-pending {
		color: #64748b;
	}

	.char-current {
		background: rgba(96, 165, 250, 0.4);
		color: white;
		animation: pulse-char 1s infinite;
	}

	@keyframes pulse-char {
		0%, 100% { background: rgba(96, 165, 250, 0.4); }
		50% { background: rgba(96, 165, 250, 0.7); }
	}

	.cursor {
		display: inline-block;
		width: 2px;
		height: 1.2em;
		background: #60a5fa;
		animation: blink-cursor 1s infinite;
		vertical-align: text-bottom;
		margin-left: 1px;
	}

	@keyframes blink-cursor {
		0%, 50% { opacity: 1; }
		51%, 100% { opacity: 0; }
	}

	.char-correct {
		color: #4ade80;
	}

	.char-incorrect {
		color: #ef4444;
		background: #450a0a;
		text-decoration: underline wavy #ef4444;
	}
</style>

<script>
	// UnifiedGraphSolver implementation
	const Mode = {
		BFS: 'BFS',
		DFS: 'DFS'
	};

	class UnifiedGraphSolver {
		solve(data, mode = Mode.BFS, track_meta = false, use_visited = true) {
			const visited = (track_meta ? {} : new Set()) && use_visited ? (track_meta ? {} : new Set()) : null;
			let result = this._init_result(visited);
			const all_starts = this._get_start_points(data);
			
			if (mode === Mode.BFS && this._is_multi_source()) {
				this._bfs(all_starts, data, visited, track_meta);
			} else {
				for (const start of all_starts) {
					if (!this._check_visited(visited, start)) {
						result = this._update_result(result);
						const nodes = [start];
						if (mode === Mode.BFS) {
							this._bfs(nodes, data, visited, track_meta);
						} else {
							this._dfs(nodes, data, visited, track_meta);
						}
					}
				}
			}
			return result;
		}

		_bfs(start_nodes, data, visited, track_meta) {
			const container = [];
			for (const node of start_nodes) {
				this._mark(visited, node, null, track_meta);
				container.push([node, 0]);
			}
			
			while (container.length > 0) {
				const [curr, level] = container.shift();
				this._process_node(curr, level);
				
				for (const neighbor of this._get_neighbors(curr, data)) {
					if (this._is_valid(neighbor, data) && !this._check_visited(visited, neighbor)) {
						this._mark(visited, neighbor, curr, track_meta);
						container.push([neighbor, level + 1]);
					}
				}
			}
		}

		_dfs(start_nodes, data, visited, track_meta) {
			const container = [];
			for (const node of start_nodes) {
				container.push([node, null]);
			}
			
			while (container.length > 0) {
				const [curr, parent] = container.pop();
				if (this._check_visited(visited, curr)) continue;
				
				this._mark(visited, curr, parent, track_meta);
				this._process_node(curr, 0);
				
				for (const neighbor of this._get_neighbors(curr, data)) {
					if (this._is_valid(neighbor, data) && !this._check_visited(visited, neighbor)) {
						container.push([neighbor, curr]);
					}
				}
			}
		}

		_check_visited(visited, node) {
			if (visited === null) return false;
			return visited instanceof Set ? visited.has(node) : node in visited;
		}

		_mark(visited, node, prev, track_meta) {
			if (visited === null) return;
			if (track_meta) {
				visited[node] = prev;
			} else {
				visited.add(node);
			}
		}

		_init_result(visited) { return visited; }
		_update_result(result) { return result; }
		_is_multi_source() { return false; }
		_get_start_points(data) { return []; }
		_get_neighbors(node, data) { return []; }
		_is_valid(node, data) { return true; }
		_process_node(node, level) { }
	}

	// TypingApp class that uses the patterns
	// TypingApp class that uses the patterns
	class TypingApp {
		constructor() {
			this.patterns = [];
			this.currentIndex = 0;
			this.includeComments = true;
			this.currentSet = 'graph';
			this.currentCode = '';
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			this.timerInterval = null;
			this.init();
		}

		async init() {
			this.setupEventListeners();
			await this.loadPatterns();
			this.displayCurrentPattern();
		}

		async loadPatterns() {
			try {
				const base = window.__BASE_URL__ || '/';
				this.patterns = [];
				
				// Fetch API
				const response = await fetch(`${base}api/flashcards.json`);
				const allCards = await response.json();
				
				// Filter for Graph Problems
				const graphCards = allCards.filter(c => c.type === 'graph-problem');
				
				for (const card of graphCards) {
					try {
						// Load Solution Code (Back File)
						const backResponse = await fetch(`${base}${card.backFile.slice(1)}`);
						if (backResponse.ok) {
							const content = await backResponse.text();
							const code = content.trim();
							
							if (code) {
								this.patterns.push({
									name: card.baseName
										.split('_')
										.map(w => w.charAt(0).toUpperCase() + w.slice(1))
										.join(' '),
									code: code,
									codeNoComments: this.removeComments(code),
									markdownUrl: `${base}${card.frontFile.slice(1)}`
								});
							}
						}
					} catch (e) {
						console.warn(`Failed to load ${card.id}`);
					}
				}
				
				document.getElementById('counter').textContent = `1 / ${this.patterns.length}`;
			} catch (error) {
				console.error('Failed to load patterns:', error);
				document.getElementById('pattern-name').textContent = 'Error loading patterns';
			}
		}

		// ... helper methods (extractCode, removeComments, formatName) ...
		extractCode(markdown) { return markdown; } // Not needed for .py files but good to keep safe
		
		removeComments(code) {
			return code
				.split('\n')
				.filter(line => !line.trim().startsWith('#'))
				.join('\n');
		}

		formatName(baseName) { return baseName; }

		setupEventListeners() {
			const input = document.getElementById('typing-input');
			const commentsToggle = document.getElementById('include-comments');
			const targetToggle = document.getElementById('show-target');
			
			input.addEventListener('input', () => this.handleInput());
			input.addEventListener('keydown', (e) => {
				if (e.key === 'Tab') {
					e.preventDefault();
					const start = input.selectionStart;
					input.value = input.value.slice(0, start) + '    ' + input.value.slice(start);
					input.selectionStart = input.selectionEnd = start + 4;
					this.handleInput();
				}
			});
			
			commentsToggle.addEventListener('change', () => {
				this.includeComments = commentsToggle.checked;
				this.updateCodeVersion();
			});
			
			targetToggle.addEventListener('change', () => {
				const targetPanel = document.querySelector('.target-panel');
				if (targetToggle.checked) {
					targetPanel.classList.remove('hidden');
				} else {
					targetPanel.classList.add('hidden');
				}
			});
			
			document.getElementById('restart-btn').addEventListener('click', () => this.restart());
			document.getElementById('prev-btn').addEventListener('click', () => this.prevPattern());
			document.getElementById('next-btn').addEventListener('click', () => this.nextPattern());
			document.getElementById('next-pattern-btn').addEventListener('click', () => this.nextPattern());
			
			document.querySelector('.input-panel').addEventListener('click', () => {
				input.focus();
			});
		}

		async displayCurrentPattern() {
			if (this.patterns.length === 0) {
				document.getElementById('pattern-name').textContent = 'Loading patterns...';
				return;
			}

			const pattern = this.patterns[this.currentIndex];
			this.currentCode = this.includeComments ? pattern.code : pattern.codeNoComments;
			
			document.getElementById('pattern-name').textContent = pattern.name;
			document.getElementById('counter').textContent = `${this.currentIndex + 1} / ${this.patterns.length}`;
			
			// Load Markdown Content
			if (pattern.markdownUrl) {
				try {
					const mdRes = await fetch(pattern.markdownUrl);
					if (mdRes.ok) {
						const mdText = await mdRes.text();
						// Use marked if available, otherwise strict text
						const html = window.marked ? window.marked.parse(mdText) : `<pre>${mdText}</pre>`;
						document.getElementById('problem-content').innerHTML = html;
					}
				} catch (e) {
					document.getElementById('problem-content').innerHTML = '<p>Failed to load problem description.</p>';
				}
			}
			
			this.renderTargetCode('');
			this.renderTypedCode('');
			this.resetStats();
			
			document.getElementById('typing-input').value = '';
			document.getElementById('typing-input').focus();
			document.getElementById('completion-message').classList.remove('show');
		}

		renderTargetCode(typed) {
			const display = document.getElementById('target-code');
			
			// Split both target and typed into lines for line-by-line comparison
			const targetLines = this.currentCode.split('\n');
			const typedLines = typed.split('\n');
			
			let html = '';
			let charIndex = 0;
			
			for (let lineIndex = 0; lineIndex < targetLines.length; lineIndex++) {
				const targetLine = targetLines[lineIndex];
				const typedLine = typedLines[lineIndex] || '';
				
				// Determine if this entire line matches
				const lineMatches = typedLine === targetLine && lineIndex < typedLines.length;
				const lineIsBeingTyped = lineIndex === typedLines.length - 1 && typedLine.length > 0;
				const lineIsComplete = lineIndex < typedLines.length - 1;
				
				// Process each character in the line
				for (let charInLine = 0; charInLine < targetLine.length; charInLine++) {
					const targetChar = targetLine[charInLine];
					const typedChar = typedLine[charInLine];
					let className = 'char-pending';
					
					if (lineMatches && lineIsComplete) {
						// Entire line is correct and complete
						className = 'char-correct-bg';
					} else if (lineIsBeingTyped) {
						// Currently typing this line - use character-by-character logic
						if (charInLine < typedLine.length) {
							className = typedChar === targetChar ? 'char-correct-bg' : 'char-incorrect-bg';
						} else if (charInLine === typedLine.length) {
							className = 'char-current';
						}
					} else if (lineIsComplete && !lineMatches) {
						// Line is complete but has errors
						if (charInLine < typedLine.length) {
							className = typedChar === targetChar ? 'char-correct-bg' : 'char-incorrect-bg';
						} else {
							className = 'char-pending'; // Missing characters
						}
					} else if (charIndex === typed.length) {
						// Current cursor position
						className = 'char-current';
					}
					
					html += `<span class="${className}">${this.escapeHtml(targetChar)}</span>`;
					charIndex++;
				}
				
				// Add newline character if not the last line
				if (lineIndex < targetLines.length - 1) {
					let newlineClass = 'char-pending';
					if (lineMatches && lineIsComplete) {
						newlineClass = 'char-correct-bg';
					} else if (lineIsBeingTyped && typedLine.length === targetLine.length) {
						newlineClass = charIndex === typed.length ? 'char-current' : 'char-correct-bg';
					} else if (lineIsComplete && typedLines[lineIndex] !== undefined) {
						newlineClass = typedLines[lineIndex] === targetLine ? 'char-correct-bg' : 'char-incorrect-bg';
					} else if (charIndex === typed.length) {
						newlineClass = 'char-current';
					}
					
					html += `<span class="${newlineClass}">\n</span>`;
					charIndex++;
				}
			}
			
			display.innerHTML = html;
		}

		renderTypedCode(typed) {
			const display = document.getElementById('typed-display');
			
			// Create a code element for Prism
			const codeEl = document.createElement('code');
			codeEl.className = 'language-python';
			codeEl.textContent = typed;
			
			// Apply syntax highlighting
			if (window.Prism) {
				Prism.highlightElement(codeEl);
			}
			
			// Add cursor at the end
			display.innerHTML = codeEl.innerHTML + '<span class="cursor"></span>';
		}

		escapeHtml(char) {
			if (char === '<') return '&lt;';
			if (char === '>') return '&gt;';
			if (char === '&') return '&amp;';
			if (char === '\n') return '\n';
			return char;
		}

		updateCodeVersion() {
			// Switch code version without resetting typed input
			const pattern = this.patterns[this.currentIndex];
			this.currentCode = this.includeComments ? pattern.code : pattern.codeNoComments;
			const typed = document.getElementById('typing-input').value;
			this.renderTargetCode(typed);
			this.renderTypedCode(typed);
			this.updateStats(typed);
		}

		handleInput() {
			const input = document.getElementById('typing-input');
			const typed = input.value;
			
			if (!this.startTime && typed.length > 0) {
				this.startTime = Date.now();
				this.startTimer();
			}
			
			this.renderTargetCode(typed);
			this.renderTypedCode(typed);
			this.updateStats(typed);
			
			if (typed === this.currentCode) {
				this.complete();
			}
		}

		updateStats(typed) {
			this.typedChars = typed.length;
			this.correctChars = 0;
			
			for (let i = 0; i < typed.length; i++) {
				if (typed[i] === this.currentCode[i]) {
					this.correctChars++;
				}
			}
			
			const accuracy = this.typedChars > 0 
				? Math.round((this.correctChars / this.typedChars) * 100) 
				: 100;
			
			document.getElementById('accuracy').textContent = `${accuracy}%`;
			
			if (this.startTime) {
				const minutes = (Date.now() - this.startTime) / 60000;
				const words = this.correctChars / 5;
				const wpm = minutes > 0 ? Math.round(words / minutes) : 0;
				document.getElementById('wpm').textContent = `${wpm} WPM`;
			}
		}

		startTimer() {
			this.timerInterval = setInterval(() => {
				const seconds = Math.floor((Date.now() - this.startTime) / 1000);
				const mins = Math.floor(seconds / 60);
				const secs = seconds % 60;
				document.getElementById('time').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
			}, 1000);
		}

		resetStats() {
			this.typedChars = 0;
			this.correctChars = 0;
			this.startTime = null;
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
				this.timerInterval = null;
			}
			document.getElementById('wpm').textContent = '0 WPM';
			document.getElementById('accuracy').textContent = '100%';
			document.getElementById('time').textContent = '0:00';
		}

		complete() {
			if (this.timerInterval) {
				clearInterval(this.timerInterval);
			}
			
			const seconds = Math.floor((Date.now() - this.startTime) / 1000);
			const mins = Math.floor(seconds / 60);
			const secs = seconds % 60;
			const accuracy = Math.round((this.correctChars / this.typedChars) * 100);
			const wpm = document.getElementById('wpm').textContent;
			
			document.getElementById('final-stats').textContent = 
				`${wpm} ‚Ä¢ ${accuracy}% Accuracy ‚Ä¢ Time: ${mins}:${secs.toString().padStart(2, '0')}`;
			document.getElementById('completion-message').classList.add('show');
		}

		restart() {
			this.displayCurrentPattern();
		}

		nextPattern() {
			this.currentIndex = (this.currentIndex + 1) % this.patterns.length;
			this.displayCurrentPattern();
		}

		prevPattern() {
			this.currentIndex = this.currentIndex === 0 
				? this.patterns.length - 1 
				: this.currentIndex - 1;
			this.displayCurrentPattern();
		}
	}

	document.addEventListener('DOMContentLoaded', () => {
		new TypingApp();
	});
</script>
</Layout>
